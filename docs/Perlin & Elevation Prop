Eric Meissner
Patrick Sharp 

Map and Sequence Project Proposal
Perlin noise & Elevation

For our project, we propose to implement a generic Perlin Noise function and a function to generate elevations of voxels. 

Perlin Noise:
  The Perlin Noise function is a pseudorandom function that generates smoothly scaling randomness, with points near each other having similar values while points far apart have distinct, non-correlated values. It will take in between two and four “coordinates” (x, y, z, t) and return a single floating point number. The user of the function then maps that value to any number of things, from smoothly scaled elevation maps to fog generation. We demonstrate one use in our elevation function. 
  http://upload.wikimedia.org/wikipedia/commons/d/da/Perlin_noise.jpg (2D perlin noise mapping values between 0-1 to grayscale)

The Elevation:
  The elevation will be a public member function of SomeClass that takes in two coordinate points, x and y, and uses two private member variables (minElevation and maxElevation) and returns the z coordinate, representing the height of solid ground at that point. It will be called from the world generation function, not provided by us, only once per (x,y) coordinate point.
  The z coordinate is generated by the Perlin noise function, and so will only generate rolling hill type landscapes for now. In the future, this can be extended to include mountains and cliffs. The elevation function calls the Perlin noise function on the world map.
  We need to discuss exactly which class will own this function and it’s needed member variables with the “Control Guys”.

Function prototypes:
  float perlin(float x, float y)
  float perlin(float x, float y, float z)
  float perlin(float x, float y, float z, float t)
  
  int SomeClass::elevation(float x, float y) 
    -Uses private minElevation and maxElevation member variables.

Theoretical Analysis
  Since each Perlin noise function call is independent of other calls, it is easily translated into the Map pattern for parallelization. Each function call scales O(2^n), where n is the number of dimensions/parameters. Thus, one 3D Perlin call takes twice as long as the 2D, and the 4D takes twice as long as the 3D. The interior of the perlin(...) function is serial, and not easily parallelized, however the use of it over a grid or world is highly parallelizable, since each cell calculation is independent of the others. 

  The elevation function merely uses and manipulates values from the 2D Perlin noise function. Likewise, it is also highly Map-able, and runs in constant time.

References
[1] http://en.wikipedia.org/wiki/Perlin_noise
